# Angular #

## Installer le CLI angular ##

    npm install -g @angular/cli

## Cr√©er un nouveau projet angular ##

    ng new <nom-du-projet> --style=scss

## Lancer le serveur ##

    ng serve

### Connecter le serveur √† votre navigateur ###

    http://localhost:4200

## Structurer votre projet angular ##

dans le dossier du projet src

le fichier index.html est le point d'entr√©e du projet c'est dans ce fichier que l'on fera les imports comme les polices de caract√®res.

le fichier styles.scss est le fichier o√π se trouvent les styles globaux de l'appli.

il contient dans le `<body>`la balise `<app-root>` qui   correspond √† la racine de votre application, ou plus pr√©cis√©ment √† l'AppComponent, le component racine de votre application. Angular sait qu'il doit remplacer cette balise par le fameux AppComponent

dans le sous-dossier app on trouve les 3 fichiers qui composent un composant angular :  
app.component.ts  
app.component.html  
app.component.scss  

dans le fichier app.component.ts on trouve

```
@Component({
  selector: 'app-root', => Le s√©lecteur d'un component correspond √† la balise HTML personnalis√©e qu'on utilisera pour l'ins√©rer dans l'application.
  templateUrl: './app.component.html', => le fichier html qui contient le code html du composant
  styleUrls: ['./app.component.scss'] => le fichier scss qui contient le code css du composant
})
```  

## Cr√©er un composant ##

    ng generate component <nom-du-composant>

Cela cr√©era un fichier  
`app.<nom-du-composant>.ts`,  
`app.<nom-du-composant>.html` et  
`app.<nom-du-composant>.scss`  
dans le dossier src/app  
`app.module.ts`  √©t√© mis √† jour pour inclure le composant cr√©√©  
on import le composant, et dans le @NgModule on l'ajoute aux d√©clarations  
  
> **Un d√©corateur en TypeScript permet, entre autres, d'apporter des modifications √† une classe. Ici, le d√©corateur  @Component  vient ajouter tous les comportements n√©cessaires √† l'utilisation de ce component dans l'application. Il est import√© depuis le package  @angular/core. Tout se passe sous le capot, on n'a pas √† s'en occuper !**

## Afficher des donn√©es dynamiques ##

notre class doit impl√©menter l'interface `OnInit`  

La m√©thode  ngOnInit()  est appel√©e automatiquement par Angular au moment de la cr√©ation de chaque instance du component. Elle permet notamment d'initialiser des propri√©t√©s.  

### ¬†La string interpolation ###

`<h1>{{title}}</h1>` il suffit de mettre le contenu de la variable entre doubles accolades

### ¬†L'attribut binding ###

`<img [src]="imageUrl" [alt]="title">`
Les crochets permettent √† Angular d'associer les valeurs des propri√©t√©s TypeScript aux attributs de l'√©l√©ment HTML.

### R√©agit aux √©v√©nements ###

dans le fichier.ts on d√©clare les m√©thodes qui seront appel√©es lors des √©v√©nements

```
onClickSnap() {
    if (this.buttonText === 'Oh Snap!') {
      this.buttonText = 'Oops UnSnap !!';
      this.faceSnapsService.snapFaceSnapById(this.faceSnap.id, 'snap');
    } else {
      this.buttonText = 'Oh Snap!';
      this.faceSnapsService.snapFaceSnapById(this.faceSnap.id, 'unsnap');
    }
  }
  ```

dans le fichier.html on a le button qui lors de l'√©v√©nement (click) appelle la m√©thode onClickSnap()

> **chaque instance d'un component est totalement ind√©pendante.  
> Pour lier une m√©thode √† un √©v√©nement d'un √©l√©ment du template, mettez l'√©v√©nement entre parenth√®ses  ()  et passez la m√©thode en argument  
> (click)="onClickButton()"**

## ¬†Ajouter des propri√©t√©s personnalis√©es ##

### Models ###

on cr√©e un dossier models  
et dedans un fichier `<nom-du-component>.models.ts`  
dans ce fichier on cr√©e un model on exporte la class et on peut aussi lui passer un constructeur

```
export class <nom-du-component> {
  id: number;
  name: string;

  constructor(id: number, name: string) {
    this.id = id;
    this.name = name;
  }
}
```

On pourra instancier cette classe avec un `new <nom-du-component>()`  

> **Pour qu'une propri√©t√© puisse √™tre inject√©e depuis l'ext√©rieur d'un component, il faut lui ajouter le d√©corateur  @Input()**

Dans le component.ts, on doit utiliser le d√©corateur @input() que l'on importe depuis l'angular/core pour indiquer que la propri√©t√© est inject√©e depuis l'ext√©rieur du component.  
`@input() nom-du-compo: type du compo`

Dans le ts du parent, il faut d√©clarer la propri√©t√© et l'initialiser.
dans le html du parent il faut utiliser l'attribut binding  
`<app-face-snap [facesnap] = "mySnap"><app-face-snap>`

## Conditionner l'affichage d'un composant ##

### ¬†ng if ###

```
<p *ngIf="faceSnap.location === 'Paris'">
```

permet de conditionner l'affichage d'un composant si une condition est vraie ou fausse

### ng for ###

```
<app-face-snap *ngFor="let faceSnap of faceSnaps" [faceSnap]="faceSnap"></app-face-snap>
```

permet de boucler sur une liste d'√©l√©ments et d'y associer la propri√©t√© faceSnap du component  

## ¬†Injecter du style dynamique ##

### ¬†ngStyle ###

```
<span [ngStyle]="{ color: 'rgb(0, ' + faceSnap.snaps + ', 0)' }">ü§å {{ faceSnap.snaps }}</span>
```

la directive ngStyle prendra comme argument un objet o√π:  

- la cl√© est le nom de la propri√©t√© css
- les valeurs sont les valeurs de cette propri√©t√©

### ¬†ngClass ###

```
<div [ngClass]="{ 'class-name': condition }"></div>
```

la directive ngClass prend comme argument un objet o√π:

- la cl√© est le nom de la classe css
- les valeurs sont les conditions qui doivent √™tre remplies pour appliquer la classe

## ¬†Les Pipes ##

Un pipe permet de formater l'affichage d'une donn√©e sans modifier la donn√©e sous-jacente.

exemple d'un pipe pour modifier la casse :

```
<h2>{{ faceSnap.title | uppercase }}</h2>
```

> **les pipes ne changent rien √† la valeur des variables sous-jacentes. Les pipes existent uniquement pour modifier le formatage affich√© d'une donn√©e : on ne peut pas les utiliser ailleurs que dans le template, et il est fortement d√©conseill√© de les utiliser ailleurs que dans une string interpolation.**

> **Il existe toutes sortes de pipe pour formater les dates, les valeurs monnaitaires, les nombres. On peut aussi cr√©e ses propres pipe**

### Changer la locale par d√©faut ###

Dans app.module.ts  

```
import { registerLocaleData } from '@angular/common';
import * as fr from '@angular/common/locales/fr';
import { LOCALE_ID } from '@angular/core';
providers: [
    { provide: LOCALE_ID, useValue: 'fr-FR' }
  ],
export class AppModule {
  constructor() {
    registerLocaleData(fr.default);
  }
}
```

## ¬†Les services ##

dans le dossier `app` on cr√©e un dossier `services`, et dedans un fichier `<nom-du-service>.ts`

> **Un service est une classe, et la fa√ßon la plus simple de d√©clarer une classe comme √©tant un service est d'utiliser le d√©corateur  @Injectable()  qui s'importe depuis  @angular/core**

```
import { Injectable } from '@angular/core';

@Injectable({
  providedIn: 'root'
})
export class FaceSnapsService {
  
}
```

> **L'objet de configuration qui sp√©cifie  providedIn: 'root'  dit √† Angular d'enregistrer ce service √† la racine de l'application. Ce sera tr√®s souvent le cas pour vos services, car √ßa permet de s'assurer de n'avoir qu'une seule instance du service, partag√©e par tous les partis int√©ress√©s.**

Pour pouvoir utiliser un service dans un component, il faut utiliser le syst√®me d'injection de d√©pendances (dependency injection ou DI) que vous fournit Angular. C'est tr√®s simple : vous passez un argument du type du service au constructor du component, et Angular vous mettra √† disposition la bonne instance du service.  

```
import { FaceSnapsService } from '../services/face-snaps.service';
//...
constructor(private faceSnapsService: FaceSnapsService) { }
```

> **On pr√©f√®re g√©n√©ralement  private  pour les injections de service, car √ßa emp√™che le template du component d'y acc√©der directement. Donner au template acc√®s aux injections serait un anti-pattern Angular ‚Äì autrement dit, une approche plus que d√©conseill√©e, souvent pour des raisons qui ne sont pas flagrantes au premier abord.**

### ¬†Les types literaux ###

```
snapFaceSnapById(faceSnapId: number, snapType: 'snap' | 'unsnap'): void {
```

On ne peut passer que `'snap'` ou `'unsnap'` en param√®tre de la m√©thode.

> **Cr√©er des types "limit√©s" comme √ßa, sous forme de literal types, ce n'est pas limit√© aux cha√Ænes de caract√®res !**

## ¬†Le routing #

dans le dossier app, on cr√©e un fichier `app-routing.module.ts`  
dans ce fichier, on importe ngModule √† partir de `@angular/core`  
on d√©clare une classe avec le d√©corateur `@NgModule()`  
au dessus de cette d√©claration, on initialise une constante routes import√© depuis `@angular/router` qui contient un tableau de routes  
Ce tableau va lier les rourtes aux components correspondants.

```
const routes: Routes = [
  { path: 'facesnaps', component: FaceSnapListComponent }
  { path: '', component: LandingPageComponent }
];
```

Pour enregistrer ces routes dans votre application, il faut les passer au routeur en passant un objet de configuration au d√©corateur  `@NgModule()`  de `AppRoutingModule` :

```
@NgModule({
  imports: [
    RouterModule.forRoot(routes)
  ],
  exports: [
    RouterModule
  ]
})
```

pour enregistrer le router module, on le rajoute dans le tableau des imports de l `app.module.ts`

Pour expliquer √† angular o√π il faut afficher le component sp√©cifi√© par le router. On utilise la balise `router-outlet` qui permet de d√©clarer un outlet dans le template du component. par exemple pour avoir le header puis en dessous le routeur, on utilise :

```
<app-header></app-header>
<router-outlet></router-outlet>
```

### Cr√©er des liens avec routerLink ###

angular utilise la directive routerLink pour cr√©er des liens. On peut l'utiliser dans la balise `<a>` et on lui passe la route vers la quelle on veut √™tre dirig√©, on est pas oblig√© d'utiliser les crochets autours de la directive car on lui passe une chaine de caract√®res :

```
<a routerLink="facesnaps">Continuer vers FaceSnaps</a>
```

On peut rajouter une extension de directive `routerLinkActive` pour ajouter du style √† un lien quand il est actif.

```
<a routerLink="facesnaps" routerLinkActive="active">Continuer vers FaceSnaps</a>
```

Ceci peut cr√©er un 'petit bug' : si on clique sur un lien, le lien est actif, mais quand on clique sur un autre lien, le lien pr√©c√©dent est encore actif.  
En fait, une route est consid√©r√©e comme √©tant active lorsqu'elle-m√™me ou l'un de ses enfants est la route s√©lectionn√©e. On voit bien que  `/facesnaps`  est un enfant de  `/`, donc finalement Angular se comporte normalement. Cependant, il existe une configuration qui permet de consid√©rer uniquement la route exacte et non ses enfants. Il suffit d'ajouter :  
`[routerLinkActiveOptions]="{ exact: true }`  √† la directive `routerLinkActive`

```
<a routerLink="" routerLinkActive="active" [routerLinkActiveOptions]="{ exact: true }">Home</a>
```

### Changer de route programmatiquement ###

dans le HTML,  on cr√©e un bouton qui va permettre de changer de route.  
sur ce bouton, on utilise la methode `onContinue()` qui va permettre de changer de route au click.

```
<button (click)="onContinue()">Continuer vers snapface</button>
```

dans le ts on importe le router et on cr√©e une m√©thode `onContinue()` qui va permettre de changer de route.

```
 constructor(private router: Router) {
  }

  onContinue(): void {
    this.router.navigateByUrl('facesnaps');
  }
```

### Activer les routes avec ActivatedRoute ###

on aura souvent besoin d'avoir acc√®s √† la route active, ce qui permet de cr√©er des routes avec un param√®tre.

on rajoute dans le router la route vers le nouveau component :

```
{ path: 'facesnaps/:id', component: SingleFaceSnapComponent }
```

Les `:id`  sp√©cifient que ce qui se trouvera apr√®s  facesnaps/  correspondra √† un param√®tre qui s'appellera `id`.

pour pouvoir r√©cup√©rer la route active, il faut injecter l'objet `ActivatedRoute` dans le constructeur du component.

```
 constructor(
    private faceSnapsService: FaceSnapsService, private route: ActivatedRoute
  ) { }
```

dans le ngOnInit, on r√©cup√©re le param√®tre `id` :

```
  const faceSnapId = this.route.snapshot.params['id'];
```

Les param√®tres d'une route sont toujours une string, pour les transformer en number il faut faire du type cast, pour r√©cup√©rer un number il faut rajouter `+` au param√®tre.

```
const faceSnapId = +this.route.snapshot.params['id'];
```

On peut donc utiliser la m√©thode getFaceSnapById de notre service pour r√©cup√©rer le snapFace correspondant √† l'id.

```
this.faceSnap = this.faceSnapsService.getFaceSnapById(faceSnapId);
```

dans le html des faceSnaps, on peut supprimer tout sauf le titre et la description et rajouter un bouton voir les d√©tails, qui redirigera vers le component SingleFaceSnapComponent du faceSnap correspondant √† l'id.

```
<button (click)="onViewFaceSnap()">Voir les d√©tails</button>
```

DAns le fichier ts on cr√©e la m√©thode `onViewFaceSnap()` qui va permettre de rediriger vers le component SingleFaceSnapComponent.

```
  onViewFaceSnap(): void {
    this.router.navigateByUrl('facesnaps/'${this.faceSnap.id});
  }
```

dans la route, on passe la variable en utilisant `${}`.

## ¬†Les observables ##

- Un Observable est un objet qui √©met des valeurs au cours du temps.

- Il est typ√© : il √©mettra toujours des valeurs du m√™me type.

- Un Observable peut √©mettre une erreur : √† ce moment-l√†, l'Observable est d√©truit et n'√©mettra plus de valeurs.

- L'Observable peut √©galement √™tre compl√©t√© : il est aussi d√©truit et n'√©mettra plus rien.

On observe un Observable avec sa m√©thode  subscribe()   pour "souscrire" √† l'Observable.

> **Il ne faut pas oublier de  unsubscribe()  quand on n'a plus besoin de l'Observable, car sinon, on court le risque de cr√©er des fuites de m√©moire ! Mais ne vous inqui√©tez pas, ce sera le sujet d'un prochain chapitre.**

par convention le nom d'un observable se termine par `$` :

```
  const interval$ = interval(1000);
```

> **un observale n'emet que lorsque l'on y a souscrit, et si on y a souscrit plusieurs fois, on cr√©e une nouvelle instance de cet observable pour chaque souscription**

>**Tr√®s souvent, l'objectif sera d'afficher les √©missions d'un Observable dans le DOM, et pour cela, Angular nous fournit `le pipe async`  . Contrairement √† tous les autres pipes que vous avez rencontr√©s jusqu'ici, `le pipe  async`  ne formate pas des donn√©es : il souscrit √† un Observable et ins√®re les √©missions dans le DOM**

dans onInit, on d√©clare un nouvel Observable :

```
  interval$!: Observable<number>;
```

dans la m√©thode ngOnInit on initialise l'Observable :

```
  this.interval$ = interval(1000);
```

dans la vue, on utilise `le pipe async` pour ins√©rer les √©missions dans le DOM :

```
  <h1>{{ interval$ | async }}</h1>
```

## Les op√©rateurs ##

on utilise les op√©rateurs pour manipuler les observables. Il existe deux types principaux d'op√©rateurs :

- les op√©rateurs bas niveau ‚Äì ces op√©rateurs touchent aux √©missions directement, g√©n√©ralement pour transformer ou filtrer ces √©missions.

- les op√©rateurs haut niveau ‚Äì ces op√©rateurs touchent √† l'Observable lui-m√™me.
  
### Les op√©rateurs bas niveau ###

>**Pour appliquer des op√©rateurs √† un Observable, on les passe, dans l'ordre, √† une m√©thode qui s'appelle  `pipe()`.On cr√©e un nouvel Observable en branchant un "tuyau" √† un autre Observable et en y ajoutant les op√©rateurs que l'on veut y ajouter. Le concept de "tuyau", pipe, en anglais, est tr√®s utile : chaque √©mission de l'Observable traverse le tuyau et donc les op√©rateurs dans l'ordre.**

1. l'op√©rateur map()
on va pour l'exemple, transformer les emissions de l'observable qui √©taient de type number en string. il faut donc changer le type de l'observable en string

```
  this.interval$ = interval(1000).pipe(
    map(value => value % 2 === 0 ? `le nombre ${value} est pair` : `le nombre ${value} est impair`)
  );
```

>**!!!! Attention pour pouvoir ins√©rer la valeur avec ${value}, il faut utiliser les backtick `**

2. l'op√©rateur filter()
on va pour l'exemple, filtrer les emissions de l'observable qui √©taient de type number et ne garder que les divisible par 3

```
  this.interval$ = interval(1000).pipe(
    filter(value => value % 3 === 0)
  );
```

3. l'op√©rateur tap()

>**En programmation r√©active, un effet secondaire est une fonction qui fait quelque chose avec les √©missions d'un Observable sans les modifier.**

on cr√©e la m√©thode logger() qui va afficher les √©missions de l'Observable dans la console.

```
  logger(text: string): void {
    console.log(`Log: ${text}`);
}
```

il reste a ajouter le tap() √† l'observable :

```
this.interval$ = interval(1000).pipe(
    filter(value => value % 3 === 0),
    map(value => value % 2 === 0 ?
        `Je suis ${value} et je suis pair` :
        `Je suis ${value} et je suis impair`
    ),
    tap(text => this.logger(text))
);
```

>**il existe de nombreux autres op√©rateurs de bas niveau**

## Les op√©rateurs de haut niveau ##

Observable de haut niveau :  c'est un observable qui souscrit √† d'autres Observables.  
Un Observable haut niveau consiste donc en un Observable ext√©rieur qui souscrit √† des Observables int√©rieurs selon ses √©missions. Quand l'Observable ext√©rieur √©met "flux 1", il souscrit √† l'Observable int√©rieur qui y correspond.
Ce sont les op√©rateurs haut niveau qui permettent ce type de souscription.

### ¬†mergeMap ###

Cet op√©rateur repr√©sente donc la mise en parall√®le : pour chaque √©mission de l'Observable ext√©rieur,  mergeMap  souscrit √† l'Observable int√©rieur sans se soucier si l'Observable int√©rieur pr√©c√©demment souscrit a compl√©t√© ou non.

```
lightObservable$.pipe(
    mergeMap(color => getTrainObservable$(color))
).subscribe();
```

>**On utilisera  mergeMap  quand l'ordre des souscriptions n'a pas besoin d'√™tre conserv√©.**  

### concatMap ###

Avec concatMap si on a une √©mission d'un observable int√©rieur avant que l'observable pr√©c√©dent ai √©t√© compl√©t√©, on stock l'ordre des √©missions et on  attend que l'Observable int√©rieur pr√©c√©demment souscrit ait √©t√© compl√©t√© , et on appel le suivant dans la liste .  

```
lightObservable$.pipe(
    concatMap(color => getTrainObservable$(color))
).subscribe();
```

>**concatMap va donc assurer la mise en s√©rie, ce qui est important quand l'ordre des op√©rations doit √™tre conserv√©.**

### ¬†exhaustMap ###

Avec exhaustMap, on ignore les autres √©missions d' Observable int√©rieur, tant que le dernier souscrit n'a pas √©t√© compl√©t√©, puis on se remet √† √©couter.

```
lightObservable$.pipe(
    exhaustMap(color => getTrainObservable$(color))
).subscribe();
```

>**exhaustMap  sera utile quand un √©v√©nement doit √™tre enti√®rement trait√© avant de permettre √† d'autres √©v√©nements d'√™tre √©mis.**

### switchMap ###

Avec switchMap on va annuler le dernier Observable int√©rieur souscrit, si celui-ci n'est pas compl√©t√©, et qu'un nouvel Observable int√©rieur a √©mit.

```
lightObservable$.pipe(
    switchMap(color => getTrainObservable$(color))
).subscribe();
```

>**Quand l'Observable ext√©rieur √©met, s'il y a d√©j√† un Observable int√©rieur en cours,  switchMap  va unsubscribe ("se d√©sabonner") de lui pour subscribe au nouveau. switchMap  servira donc quand la derni√®re √©mission de l'Observable ext√©rieur est celle qui nous int√©resse.**

En r√©sum√©:

- mergeMap  assure la mise en parall√®le : l'Observable ext√©rieur peut souscrire aux Observables int√©rieurs suivants sans attendre que les pr√©c√©dents soient compl√©t√©s.

- concatMap  assure la mise en s√©rie : il attend que les Observables int√©rieurs compl√®tent avant de souscrire aux suivants‚Äì m√™me si l'Observable ext√©rieur √©met plusieurs fois. Les Observables int√©rieurs seront trait√©s en s√©quence √† la suite.

- exhaustMap  assure le traitement complet d'une souscription avant d'observer une nouvelle √©mission de l'Observable ext√©rieur. Si d‚Äôautres demandes sont faites entre temps, elles ne seront pas prises en compte.

- switchMap  traite la derni√®re demande de souscription de l‚ÄôObservable ext√©rieur et annule toute souscription pr√©c√©dente non-compl√©t√©e.  

## Observables et fuite de m√©moire ##

1. si on utilise la m√©thode `subscribe` sur un Observable.

- Le cas le plus simple  est si on connait le nombre d'√©mission de l'observable que l'on veut.  
Dans ce cas on utilise la m√©thode `take()` √† laquelle on passe le nombre d'√©mission que l'on veut.

```
lightObservable$.pipe(
    take(3)
).subscribe();
```

- Dans le cas o√π l'on veut recevoir toutes les √©missions d'un Observable pendant la dur√©e de vie du component. Du coup, il faut trouver un moyen de compl√©ter l'Observable au moment de la destruction du component. Pour cela, vous allez utiliser le pattern "Destroy Subject".  

On utilise le `**lifecycle hook**` `ngOnDestroy` pour compl√©ter l'Observable.
Pour l'utiliser, il faut rajouter  OnDestroy  (import√© depuis  @angular/core) aux  implements  du component :

```
export class FaceSnapListComponent implements OnInit, OnDestroy {
    //...
```

on rajoute dans le composant la methode `OnDestroy():void{}`.

On cr√©e un type sp√©cial d'observable: **un subject**

Un Subject est un Observable que l'on pouve faire √©mettre √† la demande. Von cr√©e donc cr√©er un Subject appel√©  destroy$  qui √©mettra une seule fois, au moment de la destruction du component.

on le d√©clare dans notre classe :

```
export class FaceSnapListComponent implements OnInit, OnDestroy {

  faceSnaps!: FaceSnap[];
  private destroy$!: Subject<boolean>;

  constructor(private faceSnapsService: FaceSnapsService) { }
  //...
```

Dans le `onInit()` il faut initialiser `destroy$` :

```
ngOnInit(): void {
    this.destroy$ = new Subject<boolean>();
    //...
```

La derni√®re √©tape de la cr√©ation de  destroy$  est de le faire √©mettre dans  `ngOnDestroy()`  . Pour faire √©mettre un Subject, on appelle sa m√©thode  `next()` :

```
ngOnDestroy(): void {
    this.destroy$.next(true);
}
```

Maintenant il faut dire √† notre observable qui fuit de se _compl√©ter_  avec la m√©thode `takeUntil()` :

```
interval(1000).pipe(
    tap(console.log),
    takeUntil(this.destroy$)
).subscribe();
```

2. Le `pipe async`

Comme vu pr√©c√©dement, on peut souscire  √† un Observable et afficher ses √©missions dans le DOM avec le pipe async.

>**Dans ce cas,TOUT Observable souscrit avec le `pipe async` est automatiquement unsubscribe lors de la destruction du component qui le consomme.**
